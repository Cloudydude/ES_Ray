global bool fix_for_LRZ

// Make Ray have the same hitbox size as other characters
function void Character.Initialization.shared(u8 character)
{
	if (global.game_mode == 0x8c)
		zeroMemory(0x802280, 0x120)
	Move_Ray = false
	if (global.xtrachar == 2 || (global.characters != CHARS_TAILS_ALONE && character == CHARACTER_TAILS && ( (Ray_Partner == 1 && isMainCharacter(CHARACTER_SONIC) && global.xtrachar == 0) || (Ray_Partner == 2 && isMainCharacter(CHARACTER_KNUCKLES) || (Ray_Partner == 3 && global.xtrachar == 1) || Ray_Partner == 4) ) ))
	{
		MGZ2Fix = false
		TurnOffRayTail = false
		fix_for_LRZ = false
		Ray_ShowFall = false
		Force_Fall = false
		Should_fall_anim = false
		SuperFall = false

		if (Ray_Level_Transition_Fall == 1 && (global.zone_act != 0x0100) && (global.zone_act != 0x0200) && (global.zone_act != 0x0900) && (global.zone_act != 0x1600))
		{
			FreeFall = false
		}

		flapframes = 0
		Ray.Boosts = false
		Flap = true
		RayFrameCounter = 0
		
		char.base_state += 2

		char.character = character

		u8 characterHeight = 19
		char.hitbox_extends.x = 9
		char.hitbox_extends.y = characterHeight
		char.hitbox.default.x = 9
		char.hitbox.default.y = characterHeight

		if (character == CHARACTER_TAILS)
		{
			char.mapping_offset = 0x148eb8
		}

		char.sprite_priority = 0x100
		char.box_size.x = 0x18
		char.box_size.y = 0x18
		char.render_flags = render_flag.WORLD
		if (character == CHARACTER_TAILS)
			char.render_flags |= render_flag.VISIBLE

		setSpeedCapProperties(A4, false)

		u8[A0 + 0x30] = 0
		u8[A0 + 0x31] = 4
		char.drown_countdown = 30

		if (character == CHARACTER_TAILS)
		{
			if (global.characters == CHARS_TAILS_ALONE)
			{
				if (checkpoint.number == 0)
				{
					char.sprite_attributes = 0x06a0
					char.layer_flags1 = 0x0c
					char.layer_flags2 = 0x0d

					if (global.stage_type != 2)
					{
						checkpoint.x = char.position.x.u16
						checkpoint.y = char.position.y.u16
						checkpoint.sprite_attr = char.sprite_attributes
						checkpoint.layer_flags = char.layer_flags
					}
				}
			}
			else
			{
				char.sprite_attributes = 0x06a0 | (u16[0xffffb00a] & 0x8000)
				u16[A0 + 0x46] = u16[0xffffb046]
			}

			super.active.tails = 0

			if (tails.ai_routine != 0x12 && tails.ai_routine != 0x20)
				tails.ai_routine = 0

			tails.control_counter = 0
			tails.respawn_counter = 0

			// Init Tails' tails object
			u32[0xffffcc0a] = 0x0160a6
			u16[0xffffcc3a] = A0.u16

			u8[0xfffff746] = checkpoint.number
		}
		else
		{
			if (checkpoint.number == 0)
			{
				char.sprite_attributes = 0x0680
				char.layer_flags1 = 0x0c
				char.layer_flags2 = 0x0d

				if (global.stage_type != 2)
				{
					checkpoint.x = char.position.x.u16
					checkpoint.y = char.position.y.u16
					checkpoint.sprite_attr = char.sprite_attributes
					checkpoint.layer_flags = u16[A0 + 0x46]
				}
			}

			super.active = 0

			char.position.x.u16 -= 0x20
			char.position.y.u16 += 4
			ClearPositionBackup()
			char.position.x.u16 += 0x20
			char.position.y.u16 -= 4
		}
	}
	else
	{
		base.Character.Initialization.shared(character)
		return
	}
}

//# address-hook(0x006a76) end(0x006bd6)
function void InitializeGameCharacters()
{
	if (global.xtrachar == 2 || (global.characters != CHARS_TAILS_ALONE && char.character == CHARACTER_TAILS && ( (Ray_Partner == 1 && isMainCharacter(CHARACTER_SONIC) && global.xtrachar == 0) || (Ray_Partner == 2 && isMainCharacter(CHARACTER_KNUCKLES) || (Ray_Partner == 3 && global.xtrachar == 1) || Ray_Partner == 4) ) ))
	{
		IsUsingShield = false
		hang_tail = false
		RayFrameCounter = 0
		RayLookingUpFrameCounter = 0
		RayLookingDownFrameCounter = 0
	}
	
	base.InitializeGameCharacters()
}

function void ExtraChar.CompetitionMode.Character.setupPhysics(u8 xtrachar, u16 speedcap, u16 acceleration, u16 deceleration)
{
	// Ray's physics
	if (xtrachar == 0x02)
	{
		speedcap = 0x04C0
		acceleration = 0x001C
		deceleration = 0x0070
	}
	
	base.ExtraChar.CompetitionMode.Character.setupPhysics(xtrachar, speedcap, acceleration, deceleration)
}

//Fix for Lava Reef act 2 boulder cutscene, LBZ cup elevator and when Ray enters doomsday zone
function bool isMainCharacter(u8 character)
{
	if (global.xtrachar == 2)
	{
			// Lava Reef act 2 boulder cutscene						// FBZ act 2 dual plane										  // LBZ tube elevator																				  // LBZ cup elevator
		if ((D4 == 0xffffff8d && global.zone_act == 0x0901) || (global.zone_act == 0x0401 && objA0.update_address == 0x0532e0) || (global.zone_act == 0x0600 && D0.u8 == 0x10) || (global.zone_act == 0x0601 && objA0.position.x.u16 == 0x2d20 && objA0.position.y.u16 == 0x06f8))
			return false
		else if (global.zone_act == 0x0c00 && u8[0xffffb000 + 0x20] == char.state.TAILS_TRANSFORM) // doomsday zone
			u8[0xffffb000 + 0x20] = char.state.TRANSFORMING
	}
	else if (D4 == 0xffffff8d && global.zone_act == 0x0901) // If Ray is a partner
	{
		fix_for_LRZ = true
	}

    return (base.isMainCharacter(character))
}

// Fix placement when colliding with floor while gliding
function void Character.LandingOnGroundStandUp()
{
	if (global.xtrachar == 2 || (global.characters != CHARS_TAILS_ALONE && char.character == CHARACTER_TAILS && ( (Ray_Partner == 1 && isMainCharacter(CHARACTER_SONIC) && global.xtrachar == 0) || (Ray_Partner == 2 && isMainCharacter(CHARACTER_KNUCKLES) || (Ray_Partner == 3 && global.xtrachar == 1) || Ray_Partner == 4) ) ))
	{
		RayFrameCounter = 0
		D0.u8 = char.hitbox_extends.y		// Setting D0.u8 here is important for some reason
		char.hitbox_extends.x = char.hitbox.default.x
		char.hitbox_extends.y = char.hitbox.default.y
		
	#if STANDALONE
		// Correct position also if Knuckles just started gliding when hitting the ground in the same frame
		//  -> Yes, this happend, and yes, this can otherwise kill you if there's a killing blocker object in the floor
		if ((char.flags & char.flag.ROLLING) || (char.character == CHARACTER_KNUCKLES && knuckles.glideclimbstate == 0x02) || (char.character == CHARACTER_TAILS && abs(char.double_jump_state) == 1))													
	#else
		if (char.flags & char.flag.ROLLING)
	#endif
		{
			char.flags &= ~char.flag.ROLLING
			char.state = char.state.RUNNING
			D0.u8 -= char.hitbox.default.y

			s16 dy = D0.s8
			if (global.inv_gravity != (char.rotation + 0x40 >= 0x80))
				dy = -dy
			char.position.y.u16 += dy
		}
	}
	else
	{
		base.Character.LandingOnGroundStandUp()
		return
	}
}

//# address-hook(0x01c11e) end(0x01c236)
function void UpdateCameraPositionY()
{
	if (global.xtrachar != 2)
	{
		base.UpdateCameraPositionY()
		return
	}
	else
	{
		D0.s16 = char.position.y.u16 - u16[A1]
		if (level.vertical_wrap == 0xff00)
		{
			D0.s16 &= level.height.bitmask
		}
		if (char.flags & char.flag.ROLLING)
		{
			D0.s16 -= 5
		}

		#if STANDALONE
			// Prevent the infamous level wrap glitch
			if (Game.getSetting(SETTING_FIX_GLITCHES) && level.vertical_wrap == 0xff00)
			{
				if (D0.s16 > level.height.bitmask / 2)
				{
					D0.s16 -= level.height.bitmask
				}
			}
		#endif

		D1 = D3.u16
		if (competition_mode.active)
			D1.u16 >>= 1

		if (char.flags & char.flag.IN_AIR)
		{
			D0.s16 += 0x20 - D1.u16
			if (D0.s16 < 0)
			{
				D1.u16 = 0x1800
			}
			else
			{
				D0.u16 -= 0x40
				if (D0.s16 >= 0)
				{
					D1.u16 = 0x1800
				}
				else if (u8[0xffffee32] != 0)
				{
					u8[0xffffee32] = 0
					D0 = 0
				}
				else
				{
					u16[A4] = 0
					return
				}
			}
		}
		else
		{
			D0.s16 -= D1.u16
			if (D0.s16 == 0)
			{
				if (u8[0xffffee32] != 0)
				{
					u8[0xffffee32] = 0
					D0 = 0
				}
				else
				{
					u16[A4] = 0
					return
				}
			}
			else
			{
			#if !STANDALONE
				// This check leads to strange camera behavior when looking up/down on (fast) vertically moving object
				//  -> For example, on the moving ice platform in ICZ 1; this can lead to a vertical wrap glitch
				//  -> I don't know yet what this check is even for...
				if (D3.u16 != 0x60)
				{
					D1.u16 = 0x200
				}
				else
			#endif
				if (u8[0xffffee39] != 0)
				{
					D1.u16 = 0x1800
				}
				else if (abs(s16[A0 + 0x1c]) >= 0x800)
				{
					D1.u16 = 0x1800
				}
				else
				{
					D1.u16 = 0x600
				}
			}
		}

		s16 threshold = (D1.u16 >> 8)
		if (D0.s16 > threshold)
		{
			D1.s32 = D1.s16 << 8
			D1 += u32[A1]
			D1 = (D1 << 16) + (D1 >> 16)
		}
		else if (D0.s16 < -threshold)
		{
			D1.s32 = (-D1.s16) << 8
			D1 += u32[A1]
			D1 = (D1 << 16) + (D1 >> 16)
		}
		else
		{
			D1 = D0.u16
			D1.u16 += u16[A1]
		}

		if (D0.s16 < 0)
		{
			if (D1.s16 <= s16[A2 + 4])
			{
				if (D1.s16 <= -0x100)
				{
					D1.u16 &= level.height.bitmask
				}
				else
				{
					D1.u16 = u16[A2 + 4]
				}
			}
		}
		else
		{
			if (D1.s16 >= s16[A2 + 6])
			{
				u16 levelHeight = level.height.bitmask + 1
				D1.u16 -= levelHeight
				if (D1.s16 >= 0)
				{
					u16[A1] -= levelHeight
				}
				else
				{
					D1.u16 = u16[A2 + 6]
				}
			}
		}

		D4.u16 = u16[A1]
		D1 = (D1 << 16) + (D1 >> 16)
		D3 = D1 - u32[A1]
		D3 = (D3 >> 8) + (D3 << 24)
		u16[A4] = D3.u16
		u32[A1] = D1

		if (competition_mode.active)
		{
			D1 = (D1 << 16) + (D1 >> 16)
			D1.u16 &= level.height.bitmask
			u16[A1] = D1.u16
		}
	}
}

// Disable normal control while gliding
//# address-hook(0x0147b8) end(0x014820)
function void Character.UpdateTailsUprightInAir()
{
	if (global.xtrachar == 2 || (global.characters != CHARS_TAILS_ALONE && char.character == CHARACTER_TAILS) && ( (Ray_Partner == 1 && isMainCharacter(CHARACTER_SONIC) && global.xtrachar == 0) || (Ray_Partner == 2 && isMainCharacter(CHARACTER_KNUCKLES) || (Ray_Partner == 3 && global.xtrachar == 1) || Ray_Partner == 4) ))
	{
		// Flying or not?
		if (char.double_jump_state == 0)
		{
			updateTailsInAir_shared()
		}
		else if (char.double_jump_state == -1)
		{
			FadeoutSnds()
			updateTailsInAir_shared()
		}
		else
		{
			UpdateTailsFlight()
			if (char.double_jump_state == 0)	// Only needed because of flight cancel, see SETTING_CANCEL_FLIGHT
				return
			
			if (tails.ai_routine >= 0x0E)
			{
				Character.UpdateControlInAir()
			}
			
			Character.CheckAgainstMoveBorders()
			UpdateMovementStraight()
			Character.UpdateRotationInAir()

			pushA456()
			Character.CheckCollision()
			popA456()

			// Two player game?
			if (getNumPlayers() >= 2)
			{
				A2 = 0xfffff73e
				A1 = 0xffffb000
				D0.u16 = control.pad1
				Tails.UpdateCarrySonic()
			}
		}
	}
	else
	{
		base.Character.UpdateTailsUprightInAir()
		return
	}
}

//Fixes Ray continuing to glide while bouncing around on the CNZ bounce pads
//# address-hook(0x0329b8) end(0x032a72)
function void fn0329b8()
{
#if STANDALONE
	if (debug_mode.state)
		return
#endif

	D0.u16 = objA1.position.x.u16 - objA0.position.x.u16 + u16[A0 + 0x34]
	D1.u16 = objA1.position.y.u16 - objA0.position.y.u16 + 0x14
	if (D0.u16 < objA0.value32 && D1.u16 < 0x28 && u8[A1 + 0x05] < 0x04)
	{
		if (global.xtrachar == 2 || (global.characters != CHARS_TAILS_ALONE && u8[A1 + 0x38] == CHARACTER_TAILS && ( (Ray_Partner == 1 && isMainCharacter(CHARACTER_SONIC) && global.xtrachar == 0) || (Ray_Partner == 2 && isMainCharacter(CHARACTER_KNUCKLES) || (Ray_Partner == 3 && global.xtrachar == 1) || Ray_Partner == 4) ) ))
		{
			u8[A1 + 0x2f] = -1						// set jump ability
			objA1.animation.timer = 0
		}
		base.fn0329b8()
	}
}



// Stop gliding when hitting a wall
//# address-hook(0x011eec) end(0x011fd4)
//# translated(0x012012) end(0x01209c)
//# translated(0x01209e) end(0x012100)
//# translated(0x012102) end(0x012170)
//# address-hook(0x0153c2) end(0x01560a)
function void Character.CheckCollision()
{
	if (global.xtrachar == 2 || (global.characters != CHARS_TAILS_ALONE && char.character == CHARACTER_TAILS && ( (Ray_Partner == 1 && isMainCharacter(CHARACTER_SONIC) && global.xtrachar == 0) || (Ray_Partner == 2 && isMainCharacter(CHARACTER_KNUCKLES) || (Ray_Partner == 3 && global.xtrachar == 1) || Ray_Partner == 4) ) ))
	{
	#if STANDALONE
		if (A0 == 0xffffb000)
		{
			// Needed only for bubble shield bounce
			mainchar.groundhit.velocity.x = char.velocity.x
			mainchar.groundhit.velocity.y = char.velocity.y
		}
	#endif

		bool someFlag = (char.character == CHARACTER_TAILS) ? u8[0xfffff7c9] : u8[0xfffff7c8]

		u32[0xfffff796] = (char.layer_flags1 == 0x0c) ? u32[0xfffff7b4] : u32[0xfffff7b8]

		D5.u8 = char.layer_flags2
		D0.u16 = lookupAngleByVector(char.velocity.x, char.velocity.y)
		D0.u8 = (D0.u8 - 0x20) & 0xc0
		if (D0.u8 == 0)
		{
			fn00fd9a()
			if (D1.s16 < 0)
			{
				char.position.x.u16 -= D1.u16
				char.velocity.x = 0
				StopGlideIfRay()
			}

			fn00fa7a()
			if (D1.s16 < 0)
			{
				char.position.x.u16 += D1.u16
				char.velocity.x = 0
				StopGlideIfRay()
			}

			Character.CheckFloorCollision()
			if (D1.s16 < 0)
			{
				D2.u8 = (char.velocity.y >> 8) + 8
				D2.s8 = -D2.s8
				if (D0.s8 < D2.s8 && D1.s8 < D2.s8)
					return

				char.rotation = D3.u8
				char.position.y.u16 += global.inv_gravity ? -D1.s16 : D1.s16

				if (((D3.u8 + 0x20) & 0x40) == 0)
				{
					if (((D3.u8 + 0x10) & 0x20) == 0)
					{
						char.velocity.y = 0
						char.groundspeed = char.velocity.x
						Character.LandingOnGround()
						return
					}
					else
					{
						char.velocity.y >>= 1
					}
				}
				else
				{
					char.velocity.x = 0
					char.velocity.y = min(char.velocity.y, 0x0fc0)
					StopGlideIfRay()
				}

				Character.LandingOnGround()
				char.groundspeed = char.velocity.y
				if (D3.s8 < 0)
				{
					char.groundspeed = -char.groundspeed
				}
			}
		}
		else if (D0.u8 == 0x40)
		{
			fn00fd9a()
			if (D1.s16 < 0)
			{
				char.position.x.u16 -= D1.u16
				char.velocity.x = 0
				char.groundspeed = char.velocity.y
				StopGlideIfRay()
			}

			Character.CheckCeilingCollision()
			if (D1.s16 < 0)
			{
				D1.s16 = -D1.s16
				if (D1.s16 < 0x14)
				{
					if (global.inv_gravity)
						D1.s16 = -D1.s16

					char.position.y.u16 += D1.u16
					char.velocity.y = max(char.velocity.y, 0)
				}
				else
				{
					fn00fa7a()
					if (D1.s16 < 0)
					{
						char.position.x.u16 += D1.u16
						char.velocity.x = 0
						StopGlideIfRay()
					}
				}
			}
			else
			{
				if (someFlag || char.velocity.y >= 0)
				{
					Character.CheckFloorCollision()
					if (D1.s16 < 0)
					{
						char.position.y.u16 += global.inv_gravity ? -D1.s16 : D1.s16
						char.rotation = D3.u8
						char.velocity.y = 0
						char.groundspeed = char.velocity.x
						Character.LandingOnGround()
					}
				}
			}
		}
		else if (D0.u8 == 0x80)
		{
			fn00fd9a()
			if (D1.s16 < 0)
			{
				char.position.x.u16 -= D1.u16
				char.velocity.x = 0
				StopGlideIfRay()
			}

			fn00fa7a()
			if (D1.s16 < 0)
			{
				char.position.x.u16 += D1.u16
				char.velocity.x = 0
				StopGlideIfRay()
			}

			Character.CheckCeilingCollision()
			if (D1.s16 < 0)
			{
				if (global.inv_gravity)
					D1.s16 = -D1.s16

				char.position.y.u16 -= D1.u16
				if (((D3.u8 + 0x20) & 0x40) == 0)
				{
					char.velocity.y = 0
				}
				else
				{
					char.rotation = D3.u8
					Character.LandingOnGround()

					char.groundspeed = char.velocity.y
					if (D3.s8 < 0)
						char.groundspeed = -char.groundspeed
				}
			}
		}
		else 	// (D0.u8 == 0xc0)
		{
			fn00fa7a()
			if (D1.s16 < 0)
			{
				char.position.x.u16 += D1.s16
				char.velocity.x = 0
				char.groundspeed = char.velocity.y
				StopGlideIfRay()
			}

			Character.CheckCeilingCollision()
			if (D1.s16 < 0)
			{
				char.position.y.u16 -= global.inv_gravity ? -D1.s16 : D1.s16
				char.velocity.y = max(char.velocity.y, 0)
			}
			else
			{
				if (someFlag || char.velocity.y >= 0)
				{
					Character.CheckFloorCollision()
					if (D1.s16 < 0)
					{
						char.position.y.u16 += global.inv_gravity ? -D1.s16 : D1.s16
						char.rotation = D3.u8
						char.velocity.y = 0
						char.groundspeed = char.velocity.x
						Character.LandingOnGround()
					}
				}
			}
		}
	}
	else
	{
		base.Character.CheckCollision()
		return
	}
}


// Stop gliding when hitting the screen border
//# address-hook(0x0116de) end(0x011748)
//# address-hook(0x014f08) end(0x014f72)
function void Character.CheckAgainstMoveBorders()
{
	if (global.xtrachar == 2 || (global.characters != CHARS_TAILS_ALONE && char.character == CHARACTER_TAILS && ( (Ray_Partner == 1 && isMainCharacter(CHARACTER_SONIC) && global.xtrachar == 0) || (Ray_Partner == 2 && isMainCharacter(CHARACTER_KNUCKLES) || (Ray_Partner == 3 && global.xtrachar == 1) || Ray_Partner == 4) ) ))
	{
		// Get x-position (upper 16 bits = full pixel coordinate) after movement update
		u16 px = (char.position.x + (s32(char.velocity.x) << 8)) >> 16

		// Note: It might be tempting, but please do not use "getScreenWidth" to calculate rightBorder
		//  -> Instead where move_area.right is set, modify it and possibly move_area.left as well
		u16 leftBorder = move_area.left + 16
		u16 rightBorder = move_area.right + 320 - 24

		if (px < leftBorder)
		{
			char.position.x = u32(leftBorder) << 16
			char.velocity.x = 0
			char.groundspeed = 0
			StopGlideIfRay()
		}
	#if STANDALONE
		// Prevention of horizontal wrap
		else if (Game.getSetting(SETTING_FIX_GLITCHES) && leftBorder <= 0x20 && s16(px) < s16(leftBorder) && s16(px) >= s16(leftBorder) - 0x80)
		{
			char.position.x = u32(leftBorder) << 16
			char.velocity.x = 0
			char.groundspeed = 0
			StopGlideIfRay()
		}
	#endif
		else if (px > rightBorder)
		{
			char.position.x = u32(rightBorder) << 16
			char.velocity.x = 0
			char.groundspeed = 0
			StopGlideIfRay()
		}

		// Check y-position as well
		if (!global.passing_floor)
		{
			bool hitBottom = 0
			if (global.inv_gravity)
			{
				D0.s16 = level.vertical_wrap
				hitBottom = (D0.s16 >= s16(objA0.position.y.u16))
			}
			else
			{
				D0.s16 = move_area.bottom.current + getScreenHeight()
				hitBottom = (D0.s16 < s16(objA0.position.y.u16))
			}

			if (hitBottom)
			{
				// Bottomless pit kills Sonic
				Character.Die()
			}
		}
	}
	else
	{
		base.Character.CheckAgainstMoveBorders()
		return
	}
}


// Stop gliding when hitting a solid object
//# address-hook(0x01e042)
function void fn01e042()
{
	if (global.xtrachar == 2 || (global.characters != CHARS_TAILS_ALONE && u8[A1 + 0x38] == CHARACTER_TAILS && ( (Ray_Partner == 1 && isMainCharacter(CHARACTER_SONIC) && global.xtrachar == 0) || (Ray_Partner == 2 && isMainCharacter(CHARACTER_KNUCKLES) || (Ray_Partner == 3 && global.xtrachar == 1) || Ray_Partner == 4) ) ))
	{
		if (D0.u16 != 0)
		{
			if ((objA1.velocity.x >= 0) == (D0.s16 > 0))
			{
				u16[A1 + 0x1c] = 0
				objA1.velocity.x = 0
				
				push(A0)			// A0 is the solid object currently so push it to the stack
				A0 = A1				// now set it to character
				StopGlideIfRay()	// now this will work properly
				A0 = pop()			// pop A0 back
				
				if (u8[A1 + 0x37] & 0x80)
					u8[A1 + 0x37] |= 0x40
			}
		}

		objA1.position.x.u16 -= D0.u16
		u8 bit = 1 << (D6.u16 + 2)
		if (objA1.flags2a & char.flag.IN_AIR)
		{
			objA0.flags2a &= ~bit
			objA1.flags2a &= ~char.flag.PUSHING
		}
		else
		{
			objA0.flags2a |= bit
			objA1.flags2a |= char.flag.PUSHING
		}

		D6 |= (u32(1) << (D6.u16 + 13))
		D4 = 1
	}
	else
	{
		base.fn01e042()
		return
	}
}


function void StopGlideIfRay()
{
	if (tails.carrying && !MGZ2Fix)
	{
		A0 = 0xffffb000
		objA0.state = char.state.ROLLING
		u8[A0 + 0x2e] = 0
		objA0.flags2a |= char.flag.IN_AIR
		tails.carrying = 0
		tails.catch_timeout = 0
	}

	if (tails.ai_routine < 0x0E)
	{
		if (char.character == CHARACTER_TAILS && char.double_jump_state > 0)
		{
			RayGlide_Stop()
		}
	}
}


// Stop gliding when hitting dynamic objects and facing down
//# address-hook(0x0103ba) end(0x01040a)
function void fn0103ba()
{
	if (global.xtrachar == 2 || (global.characters != CHARS_TAILS_ALONE && char.character == CHARACTER_TAILS && ( (Ray_Partner == 1 && isMainCharacter(CHARACTER_SONIC) && global.xtrachar == 0) || (Ray_Partner == 2 && isMainCharacter(CHARACTER_KNUCKLES) || (Ray_Partner == 3 && global.xtrachar == 1) || Ray_Partner == 4) ) ))
	{
		if (char.double_jump_state == 1 && glideDirection == GLIDE_DOWN && (u32[A1] == 0x032eaa || u32[A1] == 0x07f344))
		{
			RayGlide_Stop()
			// char.state = char.state.RUNNING
		}
	}
	
	base.fn0103ba()
}

// Fix Tails's spindash on slopes with larger hitbox
function void releaseSpindash()
{
	if (global.xtrachar == 2 || (global.characters != CHARS_TAILS_ALONE && !isMainCharacter(CHARACTER_TAILS) && ( (Ray_Partner == 1 && isMainCharacter(CHARACTER_SONIC) && global.xtrachar == 0) || (Ray_Partner == 2 && isMainCharacter(CHARACTER_KNUCKLES) || (Ray_Partner == 3 && global.xtrachar == 1) || Ray_Partner == 4) )) && A0 != 0xffffb000)
	{
		// Release spindash!
		char.hitbox_extends.x = 7
		char.hitbox_extends.y = 14
		char.state = char.state.ROLLING
		char.flags |= char.flag.ROLLING
		char.spindash = 0

		u32 baseAddress
		s8 dy = 5
		if (char.character != CHARACTER_TAILS)
		{
			baseAddress = (super.active) ? 0x011d04 : 0x011cf2
		}
		else
		{
			baseAddress = (super.active.tails) ? 0x015320 : 0x01530e
		}
		D0 = u16(char.spindash_charge >> 8) * 2
		char.groundspeed = s16[baseAddress + D0]

		char.position.y.u16 += (global.inv_gravity) ? -dy : dy

		D0.u16 = (char.groundspeed - 0x800) * 2
		D0.u16 = 0x2000 - (D0.u16 & 0x1f00)

		// Camera delay
		if (A0 == 0xffffb000)
		{
		#if STANDALONE
			// This does not hurt
			ClearPositionBackup()
		#endif
			camera.locktime.player1 = D0.u16
		}
		else
		{
			camera.locktime.player2 = D0.u16
		}

		if (char.flags & char.flag.FACING_LEFT)
		{
			char.groundspeed = -char.groundspeed
		}

		// Tell dust cloud object to disappear again
		u8[A6 + 0x20] = 0

		playSound(SFX_SPINDASH_RELEASE)
	}
	else
	{
		base.releaseSpindash()
		return
	}
}


// Fix placement of spindash dust for Ray
//# address-hook(0x018b54) end(0x018ba4)
function void fn018b54()
{
	if (global.xtrachar == 2 || (global.characters != CHARS_TAILS_ALONE && !isMainCharacter(CHARACTER_TAILS) && ( (Ray_Partner == 1 && isMainCharacter(CHARACTER_SONIC) && global.xtrachar == 0) || (Ray_Partner == 2 && isMainCharacter(CHARACTER_KNUCKLES) || (Ray_Partner == 3 && global.xtrachar == 1) || Ray_Partner == 4) )) && A0 != 0xffffcc54)
	{
		objA0.base_state += 2
		objA0.mapping_offset = 0x018df4
		objA0.render_flags |= render_flag.WORLD
		objA0.sprite_priority = 0x80
		objA0.box_size.x = 0x10
		objA0.sprite_attributes = 0x07e0
		objA0.value42 = 0xb000
		u16[A0 + 0x40] = 0xfc00

		if (A0 != 0xffffcc54)
		{
			// Effect object for Tails
			//objA0.flags38 = 1
			if (global.characters != CHARS_TAILS_ALONE)
			{
				objA0.sprite_attributes = 0x07f0
				objA0.value42 = 0xb04a
				u16[A0 + 0x40] = 0xfe00
			}
		}

		fn018baa()
	}
	else
	{
		base.fn018b54()
		return
	}
}

// Make Ray always be vulnerable while gliding
//# address-hook(0x00ffd4) end(0x010214)
function void Character.OnCollisionWithDynamicObject()
{
	if (global.xtrachar == 2 || (global.characters != CHARS_TAILS_ALONE && char.character == CHARACTER_TAILS && ( (Ray_Partner == 1 && isMainCharacter(CHARACTER_SONIC) && global.xtrachar == 0) || (Ray_Partner == 2 && isMainCharacter(CHARACTER_KNUCKLES) || (Ray_Partner == 3 && global.xtrachar == 1) || Ray_Partner == 4) ) ))
	{
		// Example values for u8[A1 + 0x28]:
		//  - 0x06, 0x0b, 0x17, 0x1a = Different types of enemies
		//  - 0x0f		 = Boss enemy
		//  - 0x18		 = Extended arm of DEZ Chainspike
		//  - 0x23		 = AIZ Bloominator
		//  - 0x46		 = Monitor
		//  - 0x47		 = Dynamic ring
		//  - 0x87		 = Extended arm of SOZ Skorp
		//  - 0x8b, 0x9c = Flames, damaging parts of enemies
		//  - 0x8f		 = Wrecking ball
		//  - 0x98, 0x9b = Projectile
		//  - 0xd8		 = Thrown mushroom, stars over starpost

		D1.u8 = u8[A1 + 0x28] & 0xc0
		if (D1.u8 == 0)
		{
			// Collision is an enemy, i.e. is harmful, but can be attacked
			bool attacking = false
			if (char.bonus_effect & char.bonus.INVINCIBLE)
			{
				attacking = true
			}
			else if (char.state == char.state.ROLLING || char.state == char.state.SPINDASH)
			{
				attacking = true
			}
		#if STANDALONE
			else if (Game.getSetting(SETTING_DROPDASH) && char.character == CHARACTER_SONIC && char.state == char.state.SONIC_DROPDASH)
			{
				attacking = true
			}
		#endif

			if (!attacking)
			{
				bool isThreat = true						// assume true by default now
				if (char.character == CHARACTER_KNUCKLES)	// only time it isn't is as Knuckles
				{
					isThreat = (char.double_jump_state != 1 && char.double_jump_state != 3)
				}

				if (isThreat)
				{
					Character.OnThreatCollision()
					return
				}
			}

			if (u8[A1 + 0x29] != 0)
			{
				char.velocity.x = -char.velocity.x
				char.velocity.y = -char.velocity.y
				char.groundspeed = -char.groundspeed
				u8[A1 + 0x1c] = A0.u8
				u8[A1 + 0x25] = u8[A1 + 0x28]
				u8[A1 + 0x28] = 0
				--u8[A1 + 0x29]
				if (u8[A1 + 0x29] == 0)
				{
					u8[A1 + 0x2a] |= 0x80
				}
			}
			else
			{
				if (u8[A1 + 0x2a] & 0x04)
				{
					A2 = 0xffff0000 + u16[A1 + 0x3c]
					u8[A2] &= ~(1 << u8[A1 + 0x3b])
				}

				u8[A1 + 0x2a] |= 0x80

				// Grant bonus points
				Enemy.addScore(A1, 0x010216)

				objA1.update_address = 0x01e5e0
				u8[A1 + 0x05] = 0
				if (char.velocity.y < 0)
				{
					char.velocity.y += 0x100
				}
				else if (char.position.y.u16 >= objA1.position.y.u16)
				{
					char.velocity.y -= 0x100
				}
				else
				{
					char.velocity.y = -char.velocity.y
				}
			}
		}
		else if (D1.u8 == 0x40)
		{
			base.Character.OnCollisionWithDynamicObject()
		}
		else if (D1.u8 == 0x80)
		{
			// Harmful object
			Character.OnThreatCollision()
		}
		else  // D1.u8 == 0xc0
		{
			// Other interactable object
			fn0103ba()
		}
	}
	else
	{
		base.Character.OnCollisionWithDynamicObject()
		return
	}
}

//# address-hook(0x01a170) end(0x01a198)
function void fn01a170()
{
	if (global.xtrachar != 2)
	{
		base.fn01a170()
		return
	}
	// No flickies
}


// Always allow both Super and Hyper Ray, fix transformation animation, and remove the Flicky army of death
function bool Character.performSuperTransformation()
{
	if (global.xtrachar != 2 || char.character != CHARACTER_TAILS)
	{
		return base.Character.performSuperTransformation()
	}
	
	// Already super?
	if (Mods.isModActive("Characters Go Super Then Hyper"))
	{
		if (super.active == 0xff || super.active.tails == 0xff)
			return false
	}
	else
	{
		if (super.active)
			return false
	}

	if (!System.getGlobalVariableValueByName("original_mode") && !Input.buttonPressed(BUTTON_Y)) // DA Garden
		return false

	u8 possibleSuperForm = 0	// 1 for Super, 2 for Hyper

	// Tails is first player?
	if (char.character == CHARACTER_TAILS)
	{
		if (!isMainCharacter(CHARACTER_TAILS))
			return false

		if !(Mods.isModActive("Characters Go Super Then Hyper"))
		{
			if (super.active.tails)
				return false
		}
	}

	// Can go super?
	if (Mods.isModActive("Characters Go Super Then Hyper"))
	{
		if (global.super_emeralds >= 7)
		{
			if (super.active || super.active.tails)
			{
				possibleSuperForm = 2
			}
			else
			{
				possibleSuperForm = 1
			}
		}
		else if (global.chaos_emeralds >= 7 && global.traded_emeralds == 0)
		{
			possibleSuperForm = 1
		}
	}
	else
	{
		if (global.super_emeralds >= 7)
		{
			possibleSuperForm = 2
		}
		else if (global.chaos_emeralds >= 7 && global.traded_emeralds == 0)
		{
			possibleSuperForm = 1
		}
	}

	if (possibleSuperForm == 0)
		return false

	u8 RingRequirement = 50
	if (Mods.isModActive("Characters Go Super Then Hyper") && (super.active || super.active.tails))
		RingRequirement = (System.getGlobalVariableValueByName("HyperRingCost") == 0) ? 50 : (System.getGlobalVariableValueByName("HyperRingCost") == 1) ? 75 : 100

	if (ring_counter < RingRequirement || !hud.dirty.timer || char.control_flags != 0)	// Last check is needed e.g. for the snowboarding section
		return false

	super.active.tails = 1
	char.state = char.state.TRANSFORMING

	if (Mods.isModActive("Characters Go Super Then Hyper"))
	{
		if (possibleSuperForm == 2)
		{
			// the flicky army of death are on their union break

		#if STANDALONE
			super.active.tails = 0xff
		#endif
		}
		else
		{
			super.active.tails = 1
			u32[0xffffcbc0] = 0x019156
		}
	}
	else
	{
		if (possibleSuperForm == 2)
		{
			// the flicky army of death are on their union break

		#if STANDALONE
			super.active.tails = 0xff
		#endif
		}
	}

#if STANDALONE
	if (super.active == 0xff)
	{
		// Stop drowning music
		if (char.drown_countdown < 12)
		{
			playMusic(MUSIC_CTRL_FADEOUT)
		}

		// Reset drowning countdown
		char.drown_countdown = 30
	}
#endif

	if (Mods.isModActive("Characters Go Super Then Hyper"))
	{
		if (super.active == 1) || (super.active.tails == 1)
		{
			super.palettefx.state = 1
			super.palettefx.timer = 0x0f
			super.ring_dec.frames = 60
			char.control_flags = 0x81
		}
		playSound(SFX_SUPERTRANSFORM)
		#if STANDALONE
			chooseFittingMusic()	// Usually switches to super theme
		#else
			playMusic(MUSIC_INVINCIBLE)
		#endif


		setSpeedCapProperties(A4)

		char.invinc.countdown = 0
		char.bonus_effect |= char.bonus.INVINCIBLE
	}
	else
	{
		super.palettefx.state = 1
		super.palettefx.timer = 0x0f
		super.ring_dec.frames = 60
		char.control_flags = 0x81

		setSpeedCapProperties(A4)

		char.invinc.countdown = 0
		char.bonus_effect |= char.bonus.INVINCIBLE

		playSound(SFX_SUPERTRANSFORM)
	#if STANDALONE
		chooseFittingMusic()	// Usually switches to super theme
	#else
		playMusic(MUSIC_INVINCIBLE)
	#endif
	}

#if STANDALONE
	if (super.active == 0xff || super.active.tails == 0xff)
	{
		Game.setAchievementComplete(ACHIEVEMENT_GOING_HYPER)
	}
#endif
	return true
}


// Make S monitor work properly for Ray
//# address-hook(0x01da60) end(0x01db26)
function void ItemEffect.ApplySuperTransformation()
{
	if (global.xtrachar != 2 || u8[A1 + 0x38] != CHARACTER_TAILS)
	{
		base.ItemEffect.ApplySuperTransformation()
		return
	}
	
	++u16[A2]
	ring_counter += 50		// Without a check for 999 rings...
	super.palettefx.state = 1
	super.palettefx.timer = 0x0f
	super.active = 1
	super.ring_dec.frames = 60
	global.move.speedcap = 0x800
	global.move.acceleration = 0x18
	global.move.deceleration = 0xc0
	u8[0xffffb020] = 0x1f

	if (isMainCharacter(CHARACTER_SONIC))
	{
		// Sonic
		u32[0xffffb00c] = 0x146816		// "char.mapping_offset"
		super.active = 0xff
		global.move.speedcap = 0xa00
		global.move.acceleration = 0x30
		global.move.deceleration = 0x100
		u32[0xffffcd7c] = 0x019348
		u32[0xffffcbc0] = 0x01a494		// After images effect
	}
	else if (isMainCharacter(CHARACTER_TAILS))
	{
		push(A0)			// A0 is the monitor currently so push it to the stack
		A0 = A1				// now set it to character
		RayGlide_Stop()		// now this will work properly
		A0 = pop()			// pop A0 back
		
		// Tails
		super.active = 0
	#if STANDALONE
		super.active.tails = 0xff
	#else
		super.active.tails = 1
	#endif
		u8[0xffffb020] = char.state.TRANSFORMING
		u16[0xfffffec0] = 0x800
		u16[0xfffffec2] = 0x18
		u16[0xfffffec4] = 0xc0
		//u32[0xffffcd7c] = 0x01a170	// Remove Flicky army of death
	}
	else
	{
		// Knuckles
		u32[0xffffcbc0] = 0x01a494		// After images effect
	#if STANDALONE
		super.active = 0xff
	#endif
	}

	u8[0xffffb02e] = 0x81
	u8[0xffffb035] = 0
	u8[A1 + 0x2b] |= 0x02

	playSound(0x9f)
#if STANDALONE
	chooseFittingMusic()	// Usually switches to super theme
#else
	playMusic(0x2c)
#endif
}


// Use general transformation animation for Ray
//# address-hook(0x012172) end(0x012178)
//# address-hook(0x01560c) end(0x01569a)
function void Character.LandingOnGround()
{
	if (global.xtrachar != 2 || char.character != CHARACTER_TAILS)
	{
		base.Character.LandingOnGround()
		return
	}

	TurnOffRayTail = false

	Fall_Anim_Corkscrew = 0

	if ((super.active.tails & 0x80) && char.state == char.state.BALANCING2 && (char.velocity.x > 1500 || char.velocity.x < -1500))
	{
	#if GAMEAPP >= 0x22121500 // Latest update
		Input.setControllerRumble(-1, 0.5f, 21.0f, 250)
	#endif
		playSound(0x49)
		camera.hyper_knux_shake = 0x0114
		Character.ClearEnemiesOnScreen()
		global.whiteflash_timeout = 2
	}
	
	if (char.spindash == 0)
	{
	#if STANDALONE
		// Check if transforming, otherwise character gets stuck if transforming right when touching the ground
		bool transforming = char.state == char.state.TRANSFORMING
		if (transforming)
		{
			char.flags &= ~char.flag.ROLLING	// Needed so that "Character.LandingOnGroundStandUp()" does not change the state either
		}
		else
	#endif
		{
			char.state = char.state.RUNNING
		}

		Character.LandingOnGroundStandUp()
	}

	Character.LandingOnGroundResetState()
}

function void Character.LandingOnGroundResetState()
{
	if (global.xtrachar == 2 ||  (global.characters != CHARS_TAILS_ALONE && char.character == CHARACTER_TAILS) && ( (Ray_Partner == 1 && isMainCharacter(CHARACTER_SONIC) && global.xtrachar == 0) || (Ray_Partner == 2 && isMainCharacter(CHARACTER_KNUCKLES) || (Ray_Partner == 3 && global.xtrachar == 1) || Ray_Partner == 4) ))
	{
		if (abs(char.double_jump_state) == 1)
			System.setGlobalVariableValueByName("powerspringtimer_p1", 3)

		base.Character.LandingOnGroundResetState()

		// if (char.double_jump_state == 0)
		// 	RayBubbleBounce = 0

		if (RayBubbleBounce && !super.active && (char.bonus_effect & char.bonus.SHIELD_BUBBLE) && ((char.bonus_effect & char.bonus.INVINCIBLE) == 0))
		{
			System.setGlobalVariableValueByName("powerspringtimer_p1", 3)
			SonicLandingBubbleBounce()
			RayBubbleBounce = false
		}
		IsUsingShield = false
	}
	else
	{
		base.Character.LandingOnGroundResetState()
		return
	}
	// base.Character.LandingOnGroundResetState()
}


// Use general transformation animation for Ray
function void Character.updateBonusEffects()
{
	if (global.xtrachar != 2 || char.character != CHARACTER_TAILS)
	{
		base.Character.updateBonusEffects()
		return
	}
	
#if STANDALONE
	// Super Cancel
	if (Game.getSetting(SETTING_SUPER_CANCEL) && !System.getGlobalVariableValueByName("original_mode") && buttonPressed(BUTTON_Y))
	{
		bool isSuperActive = (char.character == CHARACTER_TAILS) ? super.active.tails : super.active
		u8 transformingState = char.state.TRANSFORMING
		if (isSuperActive && char.state != transformingState)
		{
			// Not in Doomsday and not in Sonic's AIZ intro
			if (global.zone_act != 0x0c00 && (char.control_flags & 0x40) == 0)
			{
				Character.cancelSuperTransformation()
				chooseFittingMusic()
				char.jumping = 0		// Do not allow another transformation until hit the ground
			}
		}
	}
#endif

	bool doRender = true
	if (char.invuln.countdown > 0)
	{
		doRender = ((char.invuln.countdown & 0x04) != 0)
		--char.invuln.countdown
	}
	if (doRender)
	{
		DrawObject()
	}

	if ((char.bonus_effect & char.bonus.INVINCIBLE) && char.invinc.countdown > 0)
	{
		if ((level.framecounter & 0x07) == 0)
		{
			--char.invinc.countdown
			if (char.invinc.countdown == 0)
			{
				// Back to normal
				if (!level.boss_encounter && char.drown_countdown >= 12)
				{
					playMusic(level.default_music)
				}
				char.bonus_effect &= ~char.bonus.INVINCIBLE

			#if STANDALONE
				// Half a second of extra invincibility
				char.invuln.countdown = max(char.invuln.countdown, 60)
			#endif
			}
		}
	}

	if ((char.bonus_effect & char.bonus.SPEED_UP) && char.speedup.countdown > 0)
	{
		if ((level.framecounter & 0x07) == 0)
		{
			--char.speedup.countdown
			if (char.speedup.countdown == 0)
			{
				char.bonus_effect &= ~char.bonus.SPEED_UP

				if (char.character != CHARACTER_KNUCKLES && competition_mode.active)
				{
					A1 = 0x1e3c00 + (char.character * 8)
					u16[A4] = u16[A1]
					u16[A4+2] = u16[A1+2]
					u16[A4+4] = u16[A1+4]
				}
				else
				{
					setSpeedCapProperties(A4)
					changeMusicTempo(0)
				}
			}
		}
	}
}


// Prevent Hydrocity hand launchers from reverting Ray's hitbox back to Tails's size
function void fn030cf8()
{
	base.fn030cf8()
	if (global.xtrachar == 2 || (global.characters != CHARS_TAILS_ALONE && u8[A1 + 0x38] == CHARACTER_TAILS && ( (Ray_Partner == 1 && isMainCharacter(CHARACTER_SONIC) && global.xtrachar == 0) || (Ray_Partner == 2 && isMainCharacter(CHARACTER_KNUCKLES) || (Ray_Partner == 3 && global.xtrachar == 1) || Ray_Partner == 4) ) ))
	{
		if (u8[A1 + 0x1e] < 0x13)
			u8[A1 + 0x1e] = 0x13
	}
}


// Remove Tails's flying sound
//# address-hook(0x0148ac)
function void UpdateTailsFlight_innerB()
{
	if (global.xtrachar == 2 || (global.characters != CHARS_TAILS_ALONE && char.character == CHARACTER_TAILS && ( (Ray_Partner == 1 && isMainCharacter(CHARACTER_SONIC) && global.xtrachar == 0) || (Ray_Partner == 2 && isMainCharacter(CHARACTER_KNUCKLES) || (Ray_Partner == 3 && global.xtrachar == 1) || Ray_Partner == 4) )))
	{
		if (char.flags & char.flag.UNDERWATER)
		{
			// Swimming
			if (tails.flight_countdown == 0)
			{
				char.state = char.state.TAILS_SWIMTIRED
			}
			else if (tails.carrying)
			{
				char.state = char.state.TAILS_SWIMCARRY
			}
			else
			{
				char.state = (char.velocity.y < 0) ? char.state.TAILS_SWIMUP : char.state.TAILS_SWIMDOWN
			}
		}
		else
		{
			// Flying
			if (competition_mode.active)
			{
				char.state = char.state.TAILS_FLYDOWN
			}
			else
			{
				if (tails.flight_countdown == 0)
				{
					char.state = char.state.TAILS_FLYTIRED
				}
				else if (tails.carrying)
				{
					char.state = (char.velocity.y < 0) ? char.state.TAILS_CARRYUP : char.state.TAILS_CARRYDOWN
				}
				else
				{
					char.state = (char.velocity.y < 0) ? char.state.TAILS_FLYUP : char.state.TAILS_FLYDOWN
				}
			}

			/*if (objA0.render_flags & render_flag.VISIBLE)
			{
				if (((level.framecounter.low + 8) & 0x0f) == 0)
				{
					playSound((char.state == char.state.TAILS_FLYTIRED) ? 0xbb : 0xba)
				}
			}*/
		}
	}
	else
	{
		base.UpdateTailsFlight_innerB()
		return
	}
}


// Don't let region code setting affect position of "Ray" results text
//# address-hook(0x02dd3e) end(0x02dd92)
function void LevelResults.UpdateCharacterNameDisplay()
{
	if (global.xtrachar != 2 || global.characters != CHARS_TAILS_ALONE)
	{
		base.LevelResults.UpdateCharacterNameDisplay()
		return
	}
	
	++objA0.animation.sprite

	A1 = 0xffff0000 + u16[A0 + 0x48]
	D0 = (u16[A1 + 0x2c] != 0) ? 0x28 : 0
	objA0.sprite_attributes = D0.u16
	objA0.update_address = 0x02dd98
	LevelResults.UpdateStaticTextDisplay()
}

// Fix for FBZ magnetic pendulum
//# address-hook(0x03d78c) end(0x03d902)
function void fn03d78c()
{
	if (global.xtrachar != 2)
	{
		base.fn03d78c()
		return
	}
	global.characters = CHARS_SONIC_ALONE 
	base.fn03d78c()
	global.characters = CHARS_TAILS_ALONE
}

// Fix for the monkeybars animation in case the wrong frames are played
//# address-hook(0x03aa7e) end(0x03ac36)
function void fn03aa7e()
{
	if (u8[A2] == 0)
	{
		fn03ac86()
		return
	}

	if ((objA1.render_flags & render_flag.VISIBLE) && debug_mode.state == 0 && u8[A1 + 0x05] < 0x04)
	{
		D0.u8 &= CONTROL_ABC
		if (D0.u8 == 0)
		{
			while (true)
			{
				if (u8[A2 + 0x04] == 0)
				{
					D2.u16 = objA0.value3e - 0x10
					if (D0 & 0x0400)
					{
						objA1.flags2a |= char.flag.FACING_LEFT
						D1.u16 = objA1.position.x.u16 - objA0.position.x.u16 + D2.u16
						if (D1.u16 != 0)
						{
							u8[A2 + 0x04] = 4
							u8[A2 + 0x02] = 1
						}
					}
					if (D0 & 0x0800)
					{
						objA1.flags2a &= ~char.flag.FACING_LEFT
						D1.u16 = objA1.position.x.u16 - objA0.position.x.u16 + D2.u16
						if (D1.u16 != D2.u16 * 2)
						{
							u8[A2 + 0x04] = 4
							u8[A2 + 0x02] = 0
						}
					}

					D0.u8 = u8[A1 + 0x2a] & char.flag.FACING_LEFT
					u8[A1 + 0x04] &= 0xfc
					u8[A1 + 0x04] |= D0.u8
					objA1.position.y.u16 = objA0.position.y.u16 + 0x12
					if (u8[A2 + 0x04] == 0)
					{
						break
					}
				}

				--u8[A2 + 0x06]
				if (s8[A2 + 0x06] >= 0)
					break

				u8[A2 + 0x06] = 7
				D1 = u8[A2 + 0x04]
				if (D1.u8 == 2)
				{
					playSound(0x4a)
				}
				--D1.u16
				u8[A1 + 0x20] = (D1.u16 == 0) ? char.state.HANGING : char.state.RUNNING

				D1.u8 += u8[A2 + 0x08]
				if (global.xtrachar == 2 || (global.characters != CHARS_TAILS_ALONE && u8[A1 + 0x38] == CHARACTER_TAILS && ( (Ray_Partner == 1 && isMainCharacter(CHARACTER_SONIC) && global.xtrachar == 0) || (Ray_Partner == 2 && isMainCharacter(CHARACTER_KNUCKLES) || (Ray_Partner == 3 && global.xtrachar == 1) || Ray_Partner == 4) ) ))
				{
					if (hang_tail)
					{
						if (D1.s16 == 7)
							D1.s16 = 3
						else if (D1.s16 == 6)
							D1.s16 = 2
						else if (D1.s16 == 5)
							D1.s16 = 1
					}
					else
					{
						if (D1.s16 == 3)
							D1.s16 = 7
						else if (D1.s16 == 2)
							D1.s16 = 6
						else if (D1.s16 == 1)
							D1.s16 = 5
					}
				}

				u8[A1 + 0x22] = u8[0x03ac38 + D1.s16]
				D1.s16 = s8[0x03ac40 + D1.s16]
				if (u8[A2 + 0x02] != 0)
				{
					D1.s16 = -D1.s16
				}
			#if STANDALONE
				if (A1 == 0xffffb000)
					globalCameraOffsetX -= D1.s16
			#endif
				objA1.position.x.u16 += D1.s16

				--u8[A2 + 0x04]
				if (u8[A2 + 0x04] != 0)
					break

				fn03ac48()

				u8[A2 + 0x06] = 0
				u8[A2 + 0x08] ^= 0x04

				if ((D0.u16 & 0x0c00) == 0)
					break
			}
		}
		else
		{
			u8[A2] = 0
			u8[A2 + 0x02] = 0x12

			D0.u16 &= 0x0f00
			if (D0.u16 != 0)
			{
				u8[A2 + 0x02] = 0x3c
			}
			if (D0 & 0x0400)
			{
				objA1.velocity.x = -0x200
			}
			if (D0 & 0x0800)
			{
				objA1.velocity.x = 0x200
			}
			objA1.velocity.y = -0x380
			u8[A1 + 0x1e] = 0x0e
			u8[A1 + 0x1f] = 0x07
			u8[A1 + 0x20] = 0x02
			u8[A1 + 0x22] = 0x96
			u8[A1 + 0x27] = 0
			objA1.flags2a |= (char.flag.IN_AIR | char.flag.ROLLING)
			objA1.flags2a &= ~(char.flag.ON_OBJECT | char.flag.CONTROL_LOCK)
			u8[A1 + 0x2e] = 0
			u8[A1 + 0x40] = 1
			u16[A1 + 0x42] = 0
		}

		D0 = u8[A1 + 0x22]
		u32 backupA2 = A2
		SetCharacterSpritePatterns()
		A2 = backupA2
	}
	else
	{
		fn03ab24()
	}
}

//Fix for DEZ Gravity teleporters
//# address-hook(0x048c44) end(0x048d2a)
function void fn048c44()
{
	if (global.xtrachar == 2 || (global.characters != CHARS_TAILS_ALONE && u8[A1 + 0x38] == CHARACTER_TAILS && ( (Ray_Partner == 1 && isMainCharacter(CHARACTER_SONIC) && global.xtrachar == 0) || (Ray_Partner == 2 && isMainCharacter(CHARACTER_KNUCKLES) || (Ray_Partner == 3 && global.xtrachar == 1) || Ray_Partner == 4) ) ))
	{
		if (debug_mode.state != 0)
			return

		D0.u16 = objA1.position.x.u16 - objA0.position.x.u16 + 3
		if (objA0.flags2a & 0x01)
		{
			D0.u16 += 0x0a
		}
		D1.u16 = objA1.position.y.u16 - objA0.position.y.u16 + 0x20

		if (D0.u16 < 0x10 && D1.u16 < 0x40)
		{
			if (u8[A1 + 0x2e] == 0 && (u8[A1 + 0x2a] & 0x02) == 0 && (u8[0xfffffab8] & 0x01) == 0)
			{
				A3 = 0xffff0000 + u16[A1 + 0x42]
				if (u32[A3] == 0x048c16)
				{
					D0.u16 = A4.u16 - A0.u16
					if (u8[A3 + D0.s16] != 0)
						return
				}

				u16[A1 + 0x42] = A0.u16
				u8[A1 + 0x2e] = 0x83
				objA1.state = char.state.RUNNING
				u16[A1 + 0x1c] = 0
				objA1.velocity.x = 0
				objA1.velocity.y = 0
				u8[A1 + 0x2a] &= ~0x20
				u8[A1 + 0x2a] |= 0x02
				objA1.position.x.u16 = objA0.position.x.u16
				if (u8[A1 + 0x2a] & 0x04)
				{
					u8[A1 + 0x2a] &= ~0x04
					D0.u8 = u8[A1 + 0x1e] - u8[A1 + 0x44]
					u8[A1 + 0x1e] = u8[A1 + 0x44]
					u8[A1 + 0x1f] = u8[A1 + 0x45]
					if (global.inv_gravity)
						D0.s8 = -D0.s8
					objA1.position.y.u16 += D0.s8
				}

				u8[A4] += 2
				u8[A4 + 1] = 0
				u16[A4 + 2] = (u8[A1 + 0x2a] & char.flag.FACING_LEFT) ? 0x600 : 0
				u16[A4 + 4] = 0

			#if STANDALONE
				// Correctly align player
				objA1.position.y.u16 = objA0.position.y.u16
				objA1.state = char.state.STANDING
			#endif
			}
		}
	}
	else
	{
		base.fn048c44()
		return
	}
}

//# address-hook(0x014534) end(0x01459c)
function void Tails.CheckCatchSonic()
{
	if (global.characters != CHARS_TAILS_ALONE && char.character == CHARACTER_TAILS && ( (Ray_Partner == 1 && isMainCharacter(CHARACTER_SONIC) && global.xtrachar == 0) || (Ray_Partner == 2 && isMainCharacter(CHARACTER_KNUCKLES) || (Ray_Partner == 3 && global.xtrachar == 1) || Ray_Partner == 4) ) )
	{
		// There's a timeout to consider
		if (u8[A2+1] != 0)
		{
			--u8[A2+1]
			if (u8[A2+1] != 0)
				return
		}

	#if STANDALONE
		// No grabbing while player 1 presses down
		if (control.pad1.state & CONTROL_DOWN)
			return
		
		if (char.state == char.state.ROLLING)
			return

		// Also no grabbing if player 1 is standing on the ground and Tails not manually controlled
		if ((u8[0xffffb02a] & char.flag.IN_AIR) == 0 && tails.control_counter == 0)
			return

		// No grabbing while Ray is gliding down
		if (glideDirection == GLIDE_DOWN)
			return
	#endif

		u16 dx = objA1.position.x.u16 - char.position.x.u16 + 0x05
		u16 dy = objA1.position.y.u16 - char.position.y.u16 + 0x08 + ((global.inv_gravity) ? 0x28 : -0x28)
		if (dx < 0x20 && dy < 0x10)
		{
			if (u8[A1 + 0x05] < 0x04 && u8[A1 + 0x2e] == 0 && u8[A1 + 0x3d] == 0 && debug_mode.state == 0)
			{
				fn01459e()
				playSound(0x4a)
				u8[A2] = 1
			}
		}
	}
	else
	{
		base.Tails.CheckCatchSonic()
		return
	}
}

//# address-hook(0x0143ba) end(0x014520)
function void Tails.UpdateCarrySonic()
{
	// In all known cases, A1 and A2 are the same here:
	//  A1 = 0xffffb000  -> Player 1 object address
	//  A2 = 0xfffff73e  -> Address of "tails.carrying"

	if (global.characters != CHARS_TAILS_ALONE && char.character == CHARACTER_TAILS && ( (Ray_Partner == 1 && isMainCharacter(CHARACTER_SONIC) && global.xtrachar == 0) || (Ray_Partner == 2 && isMainCharacter(CHARACTER_KNUCKLES) || (Ray_Partner == 3 && global.xtrachar == 1) || Ray_Partner == 4) ) )
	{
		if (u8[A2] == 0)
		{
			// Not carrying: Check if close enough to grab player 1
			Tails.CheckCatchSonic()
			return
		}

		if (u8[A1 + 0x05] < 0x04)
		{
			if ((objA1.flags2a & char.flag.IN_AIR) && (objA1.velocity.x == tails.carried_velocity_x))
			{
				if (tails.carried_velocity_y != objA1.velocity.y)
				{
					u8[A1 + 0x40] = 0
					u8[A1 + 0x2e] = 0
					u8[A2] = 0
					u8[A2+1] = 60
					return
				}

				if (s8[A1 + 0x2e] < 0)
				{
					u8[A2] = 0
					u8[A2+1] = 60
					return
				}

				bool jumpOff = (D0.u8 & CONTROL_ABC) != 0
				u16 catchTimeout = 60
			#if STANDALONE
				if (jumpOff && Game.getSetting(SETTING_TAILS_ASSIST_MODE) >= 2)		// Hybrid & Mania style only
				{
					// Don't jump off unless Down is pressed as well
					jumpOff = ((D0.u16 >> 8) & CONTROL_DOWN) != 0

					// No catch timeout in Mania style, but holding Down will prevent the catch
					if (Game.getSetting(SETTING_TAILS_ASSIST_MODE) == 3)
						catchTimeout = 0
				}
			#endif
				if (!jumpOff)
				{
					bool isLeft = ((char.flags & char.flag.FACING_LEFT) ? true : false)
					u16 x_adjust = 0x08
					u16 y_adjust = 0x20
					objA1.position.x.u16 = ((isLeft) ? char.position.x.u16 + x_adjust : char.position.x.u16 - x_adjust)
					objA1.position.y.u16 = char.position.y.u16 + (global.inv_gravity ? -y_adjust : y_adjust)

					objA1.render_flags &= ~(render_flag.FLIP_X | render_flag.FLIP_Y)
					objA1.flags2a &= ~char.flag.FACING_LEFT
					D0.u8 = char.flags & char.flag.FACING_LEFT
					objA1.render_flags |= D0.u8
					objA1.flags2a |= D0.u8
					if (global.inv_gravity)
						objA1.render_flags ^= render_flag.FLIP_Y

					--u8[A1 + 0x24]
					if (s8[A1 + 0x24] < 0)
					{
						u8[A1 + 0x24] = 0x0b
						D1 = u8[A1 + 0x23]
						D0.u8 = u8[0x014522 + D1.s16]
						if (D0.u8 == 0xff)
						{
							u8[A1 + 0x23] = 0
							D0.u8 = u8[0x014522]
						}
						else
						{
							++u8[A1 + 0x23]
						}
						u8[A1 + 0x22] = D0.u8
						D0 = u8[A1 + 0x22]

						u32 backupA2 = A2
						SetCharacterSpritePatterns()
						A2 = backupA2
					}

					s16[0xffffb000 + 0x18] = char.velocity.x
					s16[0xffffb000 + 0x1a] = char.velocity.y
					tails.carried_velocity_x = char.velocity.x
					tails.carried_velocity_y = char.velocity.y

					pushAll()
					A0 = 0xffffb000
					Character.CheckCollision()
					popAll()
				}
				else
				{
					// Jumping off
					u8[A1 + 0x2e] = 0
					u8[A2] = 0

					if (D0.u16 & 0x0f00)	// Any direction held?
					{
						u8[A2+1] = catchTimeout

						if (D0 & 0x0400)	// CONTROL_LEFT held
							objA1.velocity.x = -0x200
						if (D0 & 0x0800)	// CONTROL_RIGHT held
							objA1.velocity.x = 0x200
					}
					else
					{
						u8[A2+1] = 18
					}

					objA1.velocity.y = -0x380		// TODO: Should Knuckles have a different jump acceleration here?
					u8[A1 + 0x1e] = 0x0e
					u8[A1 + 0x1f] = 0x07
					u8[A1 + 0x20] = char.state.ROLLING
					objA1.flags2a |= (char.flag.IN_AIR | char.flag.ROLLING)
					objA1.flags2a &= ~char.flag.CONTROL_LOCK
					u8[A1 + 0x40] = 0x01

				#if STANDALONE
					playSound(SFX_JUMP)
				#endif
				}
				return
			}

			objA1.velocity.y = -0x100
			u8[A1 + 0x40] = 0
		}

		u8[A1 + 0x2e] = 0
		u8[A2] = 0
		u8[A2+1] = 60
	}
	else
	{
		base.Tails.UpdateCarrySonic()
		return
	}
}

function void SonicPressedJumpInMidAir()
{
	// Ray shouldn't use the insta-shield in competition mode
	if (competition_mode.active && competition.xtrachar == 0x02)
		return
	base.SonicPressedJumpInMidAir()
}

//Continue screen

// Prevent Sonic from appearing in Ray's continue screen
//# address-hook(0x05c52a) end(0x05c59c)
function void fn05c52a()
{
	if (global.xtrachar != 2)
	{
		base.fn05c52a()
		return
	}
}

// Reposition Ray
//# address-hook(0x05c718) end(0x05c7a4)
function void fn05c718()
{
	base.fn05c718()
	if (global.xtrachar == 2)
		objA0.position.x.u16 = 0x0120 + getScreenExtend()
}

// Disable continue icon Tails' tails
//# address-hook(0x05ca9e) end(0x05caa8)
function void fn05ca9e()
{
	if (global.xtrachar != 2)
	{
		base.fn05ca9e()
		return
	}
}

// Ignore the setting for Super and Hyper Tails
// Give Ray a Super and Hyper form
function u32 Game.getSetting(u32 settingId)
{
	if (global.xtrachar == 2 && settingId == SETTING_HYPER_TAILS)
		return 1

	return base.Game.getSetting(settingId)
}

// Fix for LBZ act 1 where the snow particles don't appear at the start
//# address-hook(0x039ad2) end(0x039b64)
function void fn039ad2()
{
	player1.control_override = 1
	player2.control_override = 1
	control.player1 = 0
	control.tails = 0

	A2 = 0xffffb000
	if (u16[A2 + 0x14] < 0x05c0)
	{
		u8[A2 + 0x2e] = 0
		u16[address1()] = 0x0400
		u16[address2()] = 0x05c0
		A2 = 0xffffb04a
		if (u32[A2] != 0)
		{
			u8[A2 + 0x2e] = 0
			u16[address1()] = 0x0400
			u16[address2()] = 0x05c0
		}

		playSound(0x82)

		player1.control_override = 0
		player2.control_override = 0
		UnloadObject()
	}
	else
	{
		fn039b46()

		A2 = 0xffffb04a
		if (u32[A2] != 0)
		{
			fn039b46()
		}
	}
}

function u32 address1()
{
	return (u8[A2 + 0x38] == CHARACTER_TAILS) ? 0xffffccbe : 0xffffcc74
}

function u32 address2()
{
	return (u8[A2 + 0x38] == CHARACTER_TAILS) ? 0xffffccb2 : 0xffffcc68
}